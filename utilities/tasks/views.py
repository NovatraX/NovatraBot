import discord
from typing import Dict, List

from utilities.tasks.utils import normalize_priority, priority_rank


class TaskEditModal(discord.ui.Modal):
    def __init__(self, view, task: Dict):
        super().__init__(title="Edit Task")
        self.view = view
        self.task = task

        self.task_text = discord.ui.InputText(
            label="Task",
            style=discord.InputTextStyle.long,
            value=task.get("text", ""),
            max_length=500,
        )
        self.priority = discord.ui.InputText(
            label="Priority (urgent, high, medium, low)",
            value=task.get("priority", ""),
            max_length=30,
            required=False,
        )

        self.add_item(self.task_text)
        self.add_item(self.priority)

    async def callback(self, interaction: discord.Interaction):
        new_text = self.task_text.value.strip()
        new_priority = normalize_priority(self.priority.value)

        if new_text:
            self.view.db.update_task_text(self.task["id"], new_text)
            self.task["text"] = new_text

        self.view.db.update_task_priority(self.task["id"], new_priority)
        self.task["priority"] = new_priority

        await self.view.update_message(interaction, use_message=True)


class TaskReviewView(discord.ui.View):
    def __init__(
        self,
        linear_client,
        db,
        tasks: List[Dict],
        user: discord.User,
        channel: discord.TextChannel,
        batch_id: int,
        provider_label: str = "AI",
        message: discord.Message = None,
    ):
        super().__init__(timeout=3600)
        self.linear = linear_client
        self.db = db
        self.user = user
        self.channel = channel
        self.batch_id = batch_id
        self.message = message
        self.provider_label = provider_label
        self.upload_in_progress = False

        self.tasks = sorted(
            tasks,
            key=lambda item: (
                priority_rank(item.get("priority")),
                item.get("source_message_ts") or 0,
            ),
        )
        self.current_index = 0

    def _status_label(self, status: str) -> str:
        return {
            "pending": "â³ Pending",
            "approved": "âœ… Approved",
            "rejected": "âŒ Rejected",
            "uploaded": "ðŸ“¤ Uploaded",
            "failed": "âš ï¸ Upload Failed",
            "completed": "ðŸ Completed",
        }.get(status, status)

    def _priority_color(self, priority: str) -> int:
        colors = {
            "urgent": 0xFF0000,
            "high_priority": 0xFFA500,
            "medium_priority": 0xFFD966,
            "low_priority": 0x00C853,
        }
        return colors.get(normalize_priority(priority), 0x0099FF)

    def _priority_label(self, priority: str) -> str:
        label = normalize_priority(priority).replace("_", " ")
        return label.title()

    def current_task(self) -> Dict:
        if not self.tasks:
            return {}
        if self.current_index < 0 or self.current_index >= len(self.tasks):
            return {}
        return self.tasks[self.current_index]

    def current_embed(self) -> discord.Embed:
        if not self.tasks or self.current_index >= len(self.tasks):
            return self.summary_embed()

        task = self.current_task()
        if not task:
            return self.summary_embed()
        priority_label = self._priority_label(task.get("priority"))
        status_label = self._status_label(task.get("status", "pending"))
        description = f"**Task:** {task.get('text', '')}\n"
        description += f"**Priority:** {priority_label}\n"
        description += f"**Status:** {status_label}\n"

        if task.get("source_message_link"):
            description += f"**Source:** {task['source_message_link']}\n"
        if task.get("linear_issue_url"):
            description += f"**Linear:** {task['linear_issue_url']}\n"

        description += "\nUse the buttons below to review, edit, and upload approved tasks to Linear."

        embed = discord.Embed(
            title=f"ðŸ“‹ Task {self.current_index + 1}/{len(self.tasks)}",
            description=description,
            color=self._priority_color(task.get("priority")),
            timestamp=discord.utils.utcnow(),
        )
        embed.set_footer(text=f"Generated by {self.provider_label} â€¢ {self.user.display_name}")
        return embed

    def summary_embed(self) -> discord.Embed:
        counts = {
            "pending": 0,
            "approved": 0,
            "rejected": 0,
            "uploaded": 0,
            "failed": 0,
            "completed": 0,
        }
        for task in self.tasks:
            counts[task.get("status", "pending")] = (
                counts.get(task.get("status", "pending"), 0) + 1
            )

        embed = discord.Embed(
            title="ðŸ“‹ Task Review Summary",
            description="Review session complete. You can still upload approved tasks.",
            color=0x0099FF,
            timestamp=discord.utils.utcnow(),
        )
        embed.add_field(
            name="Totals",
            value=(
                f"Approved: {counts['approved']}\n"
                f"Rejected: {counts['rejected']}\n"
                f"Pending: {counts['pending']}\n"
                f"Uploaded: {counts['uploaded']}\n"
                f"Failed: {counts['failed']}"
            ),
            inline=False,
        )
        uploaded_links = [
            task["linear_issue_url"]
            for task in self.tasks
            if task.get("linear_issue_url")
        ]
        if uploaded_links:
            joined_links = "\n".join(uploaded_links)
            if len(joined_links) > 1024:
                trimmed = []
                total = 0
                for link in uploaded_links:
                    if total + len(link) + 1 > 1010:
                        trimmed.append("...")
                        break
                    trimmed.append(link)
                    total += len(link) + 1
                joined_links = "\n".join(trimmed)
            embed.add_field(
                name="Uploaded Links",
                value=joined_links,
                inline=False,
            )
        embed.set_footer(text=f"Generated by {self.provider_label} â€¢ {self.user.display_name}")
        return embed

    def _all_reviewed(self) -> bool:
        return all(task.get("status") != "pending" for task in self.tasks)

    def _all_uploaded_or_final(self) -> bool:
        final_statuses = {"uploaded", "failed", "rejected", "completed"}
        return all(task.get("status") in final_statuses for task in self.tasks)

    async def update_message(
        self, interaction: discord.Interaction, use_message: bool = False
    ):
        embed = self.current_embed()
        if use_message and self.message is not None:
            try:
                await self.message.edit(embed=embed, view=self)
            except Exception:
                pass
            if not interaction.response.is_done():
                await interaction.response.defer()
            return

        if interaction.response.is_done():
            await interaction.edit_original_response(embed=embed, view=self)
        else:
            await interaction.response.edit_message(embed=embed, view=self)

    async def _advance(self, interaction: discord.Interaction):
        self.current_index += 1
        if self.current_index >= len(self.tasks):
            if interaction.response.is_done():
                await interaction.edit_original_response(
                    embed=self.summary_embed(), view=self
                )
            else:
                await interaction.response.edit_message(
                    embed=self.summary_embed(), view=self
                )
        else:
            await self.update_message(interaction)

    def _ensure_owner(self, interaction: discord.Interaction) -> bool:
        if interaction.user != self.user:
            return False
        return True

    @discord.ui.button(label="Approve", style=discord.ButtonStyle.green, row=0)
    async def approve(self, button: discord.ui.Button, interaction: discord.Interaction):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can review this task.", ephemeral=True
            )
            return

        task = self.current_task()
        self.db.set_task_status(task["id"], "approved")
        task["status"] = "approved"
        if self._all_reviewed():
            self.db.update_batch_status(self.batch_id, "reviewed")
        await self._advance(interaction)

    @discord.ui.button(label="Reject", style=discord.ButtonStyle.red, row=0)
    async def reject(self, button: discord.ui.Button, interaction: discord.Interaction):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can review this task.", ephemeral=True
            )
            return

        task = self.current_task()
        self.db.set_task_status(task["id"], "rejected")
        task["status"] = "rejected"
        if self._all_reviewed():
            self.db.update_batch_status(self.batch_id, "reviewed")
        await self._advance(interaction)

    @discord.ui.button(label="Skip", style=discord.ButtonStyle.secondary, row=0)
    async def skip(self, button: discord.ui.Button, interaction: discord.Interaction):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can review this task.", ephemeral=True
            )
            return

        await self._advance(interaction)

    @discord.ui.button(label="Edit", style=discord.ButtonStyle.blurple, row=0)
    async def edit(self, button: discord.ui.Button, interaction: discord.Interaction):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can edit this task.", ephemeral=True
            )
            return

        modal = TaskEditModal(self, self.current_task())
        await interaction.response.send_modal(modal)

    @discord.ui.button(label="Approve All", style=discord.ButtonStyle.green, row=1)
    async def approve_all(
        self, button: discord.ui.Button, interaction: discord.Interaction
    ):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can review tasks.", ephemeral=True
            )
            return

        pending_ids = []
        for task in self.tasks:
            if task.get("status") == "pending":
                task["status"] = "approved"
                pending_ids.append(task["id"])

        self.db.set_task_status_bulk(pending_ids, "approved")
        if self._all_reviewed():
            self.db.update_batch_status(self.batch_id, "reviewed")
        await self.update_message(interaction)

    @discord.ui.button(label="Reject All", style=discord.ButtonStyle.red, row=1)
    async def reject_all(
        self, button: discord.ui.Button, interaction: discord.Interaction
    ):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can review tasks.", ephemeral=True
            )
            return

        pending_ids = []
        for task in self.tasks:
            if task.get("status") == "pending":
                task["status"] = "rejected"
                pending_ids.append(task["id"])

        self.db.set_task_status_bulk(pending_ids, "rejected")
        if self._all_reviewed():
            self.db.update_batch_status(self.batch_id, "reviewed")
        await self.update_message(interaction)

    @discord.ui.button(label="Upload Approved", style=discord.ButtonStyle.blurple, row=1)
    async def upload_approved(
        self, button: discord.ui.Button, interaction: discord.Interaction
    ):
        if not self._ensure_owner(interaction):
            await interaction.response.send_message(
                "Only the task owner can upload tasks.", ephemeral=True
            )
            return

        if self.upload_in_progress:
            await interaction.response.send_message(
                "Upload already in progress.", ephemeral=True
            )
            return

        if not self.linear.client or not self.linear.team_id:
            await interaction.response.send_message(
                "Linear integration is not configured.", ephemeral=True
            )
            return

        approved_tasks = [task for task in self.tasks if task.get("status") == "approved"]
        if not approved_tasks:
            await interaction.response.send_message(
                "No approved tasks to upload.", ephemeral=True
            )
            return

        self.upload_in_progress = True
        await interaction.response.defer()

        for task in approved_tasks:
            result = await self.linear.create_issue_for_task(task, self.user, self.channel)
            if result:
                task["status"] = "uploaded"
                task["linear_issue_id"] = result.get("id")
                task["linear_issue_url"] = result.get("url")
                self.db.mark_task_uploaded(task["id"], result.get("id"), result.get("url"))
            else:
                task["status"] = "failed"
                self.db.mark_task_failed(task["id"])

        self.upload_in_progress = False
        if self._all_uploaded_or_final():
            self.db.update_batch_status(self.batch_id, "uploaded")
        await self.update_message(interaction)
